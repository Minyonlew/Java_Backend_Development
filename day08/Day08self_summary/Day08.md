# Java Development

### Day 08  抽象类   关于对象比较 ==和equals()



### 1、为什么需要抽象类?如何定义抽象类?

- **抽象类** 是一种**模版模式**。**抽象类为所有子类提供了一个通用模版，子类可以在这个模版基础上进行扩展。**

- **通过抽象类，可以避免子类设计的随意性。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。**

  ```java
  abstract class Pet{
  	private String name;  //抽象类可以有非抽象类的成员变量
      private int age;
      
      Pet(){   			//抽象类可以有非抽象类的方法，也可以没有抽象方法
          
      }
      abstract  void shout(); //抽象方法没有方法体！
  
  }
  class Dog extends Pet {
  
  	void shout() {  //必须重写父类的抽象方法否则编译通不过
  		System.out.println("旺旺旺！");
  	}	
  }
  ```

- **注意：**

  - 抽象方法和抽象类均必须用abstract来修饰。
  - 抽象方法没有方法体，只需要声明不需实现。
  - 有抽象方法的类只能定义能抽象类。
  - 相反抽象类里面的方法不一定全是抽象方法，也可能没有抽象方法。
  - 抽象类可以包含属性、方法、构造方法。
  - 抽象类不能实例化，及不能用new来实例化抽象类，只能用来被子类调用。 
  - 抽象类只能用来继承。
  - 抽象方法必须被子类实现。抽象类的子类必须覆盖所有的抽象方法才能被实例化，否则还是抽象类



### 2、关于对象比较 ==和equals()

- **==**：

  - **比较两基本类型变量的值是否相等。**
  - 比较 **<u>两个引用类型的值</u> **即**内存地址是否相等**，即是否**指向同一对象。**

- **equals() ：**

  - 通过查看API文档，发现Object 上的equals()方法的描述是这样的：

    ```java
    // Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。 
    
    //总的来说 就是跟 == 实现的效果差不多！！！
    ```

    

  - **但是，对应两个字符串进行比较，一般都是比较其内容是否相等，而不是判断两个字符串引用是否指向同一对象。**为此，通过API文档可以发现，**很多类都是对equals()方法进行了重写。**

    ```java
    //例如String类  API中的描述：
    //  public boolean equals(Object anObject)
    //	将此字符串与指定的对象比较。当且仅当该参数不为 null，并且是与此对象表示相同字符序列的 String 对象时，结果才为 true。 
    ```

    

